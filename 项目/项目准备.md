## Shine i8000交叉污染功能开发

面试官您好，接下来我介绍一下交叉污染功能开发的这一个任务

这个任务是我个人认为比较自豪的一个项目，也是非常复杂的一个业务，包括后面做的云会议开源项目的整体思路也是源于对这个业务的理解。该功能的主要任务分为六个模块：<font color=red>交叉污染的系统设置</font>，<font color=red>交叉污染对的设置</font>，<font color=red>交叉污染信息的存储</font>，<font color=red>交叉污染对在后端的使用、修改流程</font>，<font color=red>交叉污染检查库开发</font>，<font color=red>多机型适配</font>。

---

首先想要开展业务，需要先对项目整体架构以及交叉污染需求进行了解：

**项目整体架构：**与传统的C-S架构模式不同，由于项目需要适配四联机，所以需要4个后端，项目采用`客户端->中控->后端1/2/3/4`的形式，其中中控存有中控前端数据库以及后端1/2/3/4的映射数据库，中控前端数据库的作用是给中控，前端提供一个可以便捷访问的本地数据库；后端存有后端数据库，在对后端数据库进行改写之后，会同步到中控对应的映射数据库并按情况更新到中控数据库，同时通知给前端。

**交叉污染需求：**Shine i8000用于体外诊断，即检测人的体液样本中是否存在某种特定病症。其中样本指的是人类体液，试剂用于检测人类体液。在检测时，需先用样本针将样本加入反应杯中，然后用试剂针L/R加入试剂。此时完成第一份样本的第一个测试的加样，在进行第二个测试的加样前，会触发样本针/试剂针的交叉污染，其中交叉污染类型分为`样本间交叉污染`和`试剂间交叉污染`，其中样本间污染指的是某个项目存在样本间污染，即：高浓度的样本容易对低浓度的样本产生携带污染，为了规避污染，在样本间切换时进行插入清洗。如何判断该样本会对其他样本有污染，若该样本中包含了特定的检测项目，即确定该样本会对下一个样本有污染；而试剂间污染指的是某两个项目之间存在试剂间污染，即A项目测试会对B项目测试产生污染。为了规避污染，在A与B项目间插入清洗。 这种方式也可通过项目间排序测试规避也可以从插入特殊的周期进行清洗。

---

在了解完项目整体架构以及交叉污染需求之后，现在介绍一下业务整体的开发，该业务整体分为交叉污染客户端开发，以及交叉污染服务端开发：

**交叉污染客户端开发：**首先说交叉污染的客户端开发。交叉污染客户端开发分为两个界面，第一个界面用于交叉污染系统设置以及显示交叉污染对；第二个界面用于自定义交叉污染对。

1. **交叉污染系统设置：**对于交叉污染系统设置而言，我们需要设置的是交叉污染开关，清洗液类型，强化清洗液容积，以及使用model/view显示交叉污染对。对于交叉污染系统设置，点击保存之后需要通知给所有后端数据库并且同步更新到中控前端数据库。在点击编辑，新增按钮时，可以进入交叉污染对设置界面

2. **交叉污染对设置：**对于交叉污染对而言，我们需要设置的是交叉污染类型，污染源，受污染项目，以及清洗次数，其中污染源与被污染项目之间存在一对一，一对多，多对一的关系。对于样本间交叉污染，存在同一根样本管不同测试之间的交叉污染，以及不同样本管不同测试之间的交叉污染，试剂间交叉污染也是同理。

   **重点：**在系统设置界面点击编辑按钮的时候，我们需要切换显示已选择已选择的污染源/被污染项目，如果此时采用信号槽的方式连接，会导致代码冗余度很高，而且频繁使用信号槽会降低系统运行效率。通过研究，最终采用了eventfilter过滤派发下来的事件，这样在不使用信号槽的情况下，可以一定程度上提高我们系统运行的效率。

**交叉污染服务端开发：**服务端的开发是本次开发的一个重点内容，主要分为三个部分：交叉污染对的存储，交叉污染对在后端的使用，交叉污染检查库的开发。

1. **交叉污染对的存储：**首先说交叉污染对的存储。本身污染对的存储不难，原本的流程是按照公司的通信协议在前端打包好要存储的系统设置/污染对，然后在后端创建一个交叉污染表的类，对前端的数据进行解析，然后存入数据库。需要注意的是系统设置和污染对存储走的是两条不同的路径，系统设置存储在系统表中，存储之后需要同步更新到内存；污染对存储在污染表中，存储之后不用同步更新到内存。需要注意两者在数据库完成存储之后都需要同步通知中控数据库更新并且通知到前端更新显示界面。

   **重点：**该模块的一个重点是由于以往的数据管理不规范，导致前后端代码耦合度过高，占用了大量网络传输的消息ID，所以以往进行网络传输的代码逻辑不具备参考性，需要我进行重新优化。

   在优化之前，首先我们要明白为什么以前的不行，在仔细研究之后，他主要体现在以下两个方面：

   - 在以前前端对数据进行打包的时候，他会按照字段顺序进行打包。比如我有三个字段名A，B，C，对应的数据分别为1，2，3，那么在存储的时候就是直接存储的1，2，3，解析的时候按顺序解析出1，2，3，并存储到A，B，C中，普通情况下是没问题的，但如果我在前端不小心存储成了1，3，2，这样在后端存储到数据库中的时候B和C就存反了。
   - 第二点就是说比如我需要对污染对进行增加，修改，删除。按照以往的逻辑，增加需要占一个消息ID，修改需要占一个消息ID，删除也需要占一个消息ID，也就是说对于一张表我至少需要3个消息ID，当表的数量一多起来，会造成整体代码的冗余度非常高，在后端一个接收前端数据的一个接口，一个函数就达到了2w行，这是非常不好的。
   - 那么结合以上两点，我制定了以下新的规范：首先看公司自定义的网络通信协议，主要分为三部分：消息ID，字符串，字符串数组。其次看公司后端的线程通信协议，主要也分为三个部分：消息ID，一维字符串数组，二维字符串数组。对于`消息ID`而言，我规定用于存放要操作的数据库名称，比如我要将污染对存放在A数据库的A3数据表中，那此时消息ID应该存A数据库的名称；而`字符串/一维字符串数组`中应该存放具体要操作的数据表名称和数据表的操作，两者之间用逗号隔开；`字符串数组/二维字符串数组`中应该按照“字段名1@@数据1，字段名2@@数据2……”的形式进行存储，其中字段名与数据之间用@@进行隔开，不同字段名之间使用逗号进行隔开，一条记录对应一个一维数组。这样新的规定就可以很好的解决以上问题

交叉污染在后端的使用以及交叉污染库的开发是本次项目两个最大的难点，在进行这两个模块的开发前，我们首先需要阅读代码，了解两个东西，一个是后端的整体架构，另一个是状态机：首先项目入口是main.cpp和AllEntry.cpp，在这两个文件里面会先初始化后端的所有线程并使线程进入轮询状态。我接触了四个线程，分别是：DataServer，LocalServer，DriverBoardServer，DriverBoardServerHandle。

**DataServer：**用于数据处理，并存入数据库。

**LocalServer：**用于指令调度，其中有两个很关键的东西，一个叫排序库，一个叫CycleActionHandle的单例类，其中排序库会把Localserver提交上来的所有指令进行排序，并将排序结果以数据帧的形式返回给LocalServer，然后LocalServer再将该帧发送给DriverBoardServer，DriverBoardServer再发送给MCU。需要注意对于Shine i8000的机型而言，是4s一个周期，所以我调用排序接口，以及转发给DriverBoardServer线程的时间间隔也是4s。然后就是CycleActionHandle类，他大致的用途是对样本和该样本的测试结果进行绑定，因为当我在第二个周期收到一个测试结果时，该测试结果对应的不一定是当前周期申请测试的样本，而是第一个周期申请测试的样本，

**DriverBoardServer：**用于与MCU进行通信，包括接收，解密MCU传来的信息，并向MCU下发数据帧（周期指令）

**DriverBoardServerHandle：**由于解密MCU信息会占用过长的时间，所以该类的作用是给DriverBoardServer减负。

对于接下来的工作，我们需要重点关注LocalServer，DataServer即可

接下来讲一下状态机，他是结合着消息队列进行实现的：首先他会接收前端/MCU发来的状态改变信号，并且通知到MCU/后端，并且将结果广播到后端的所有线程中。

2. **交叉污染对在后端的使用、修改：**在项目代码中，什么时候会触发交叉污染呢？当DataServer检测到状态机的状态由待机->预运行的时候，我们需要从数据库中查询污染对，并且通知LocalServer更新排序库以及接下来要说的检查库中的交叉污染对。按常理来说，更新完污染对之后，交叉污染的业务就已经结束了。但实际测试的时候发现在触发交叉污染的时候，不论怎么设置，都只能使用普通清洗。结合日志以及断点调试，发现该问题是由于排序库无法识别清洗类型造成的，需要对排序库的结果进行修改，并且由于排序库的不稳定，还需要开发交叉污染检查库对最终的结果进行检验。所以我才会花费很大的精力去了解项目中的状态机，各个线程的作用，以及样本测试的整体流程，这样我才知道后续的代码该写在哪里。

   那现在掌握了前置知识之后，我需要去修改排序库的结果。显然排序库会在周期指令发送之前下发结果，而指令调度是由LocalServer负责的，所以我们应该在LocalServer中寻找相关函数。而且由于在清洗周期中我可能会对采样针，试剂左针，试剂右针同时进行清洗，所以在当前周期分别检测采样针，试剂左针，试剂右针的清洗液类型，那么如何判断当前周期的清洗类型？我们之前在存储完交叉污染系统设置的时候会同步更新到内存中，所以我们只需要根据内存中的数据去更新清洗液类型就好了。需要注意在我们在进行强化清洗液扣减的时候，试剂的强化清洗液和样本的强化清洗液是存放在不同的地方的。而且强化清洗液是存放在试剂盒里的，而试剂盒分为四个试剂腔，我们需要对每个试剂腔进行检查，然后扣减。

   在修改完周期指令之后，对周期指令的合法性进行检查。为了整体系统的运行效率，我们只有在样本针/试剂针有吸样/清洗动作时才会对该周期指令进行检查，检查的方式是将对应的数据传入接下来的交叉污染检查库进行检查。

3. **交叉污染检查库的开发：**该库的功能是用于检查排序库的结果是否违反交叉污染规则，如果在吸污染源后未完成足够次数的清洗，就吸被污染项目，则视为违反交叉污染规则。在检查库的开发之前，我们要再捋一遍交叉污染的业务逻辑。首先对于一个交叉污染对而言，分为样本间交叉污染和试剂间交叉污染，污染对的对应关系为1对1，1对多，多对1。其中对于试剂间交叉污染来说，如果污染源与被污染项目位于不同的试剂盘上时，不应该触发交叉污染；在进行解除污染时，有4种类型的清洗：①在加样完成之后固定的周期清洗，该清洗不能算入清洗周期。②插空周期的普通清洗，这个是触发交叉污染规则之后排序库专门安排的一个用于清洗的清洗周期，所以算一次清洗。③插空周期的强化清洗，同理，这个也算一次清洗。注意当强化清洗液耗尽时，会降级为普通清洗，此时也算一次清洗。④重新排列测试顺序，使得项目间插入其他不会被污染的项目，利用周期清洗来解除污染，这个也算一次清洗，对于该类型的清洗来说，既可以当作是普通清洗，也可以当作是强化清洗。整体逻辑还是稍微有点复杂的。

   在捋清楚逻辑之后，该检查库的开发大致分为三部分：①初始化的时候添加污染对，这部分我使用哈希表，key是被污染项目名，value是对应的污染对信息。②在下发周期指令前如果针有吸样/清洗动作的话，就记录该动作，并将之前加样的那些项目的清洗次数加一。③记录完动作之后检查当前周期加样的项目是否违反交叉污染规则，这个是结合第一步和第二步操控的内存进行比较的。

4. **多机型适配：**这个是很简单的内容了，与Shine i8000相比只是周期指令存储的位置不同，改一下枚举值就好了。

## Shine i8000测试作废功能开发



## 基于Qt+Linux的云会议平台

