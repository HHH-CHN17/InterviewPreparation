## Shine i8000交叉污染功能开发

面试官您好，接下来我介绍一下交叉污染功能开发的这一个任务

这个任务是我个人认为比较自豪的一个项目，也是非常复杂的一个业务，包括后面做的云会议开源项目的整体思路也是源于对这个业务的理解。该功能的主要任务分为六个模块：<font color=red>交叉污染的系统设置</font>，<font color=red>交叉污染对的设置</font>，<font color=red>交叉污染信息的存储</font>，<font color=red>交叉污染对在后端的使用、修改流程</font>，<font color=red>交叉污染检查库开发</font>，<font color=red>多机型适配</font>。

---

首先想要开展业务，需要先对项目整体架构以及交叉污染需求进行了解：

**项目整体架构：**与传统的C-S架构模式不同，由于项目需要适配四联机，所以需要4个后端，项目采用`客户端->中控->后端1/2/3/4`的形式，其中中控存有中控前端数据库以及后端1/2/3/4的映射数据库，中控前端数据库的作用是给中控，前端提供一个可以便捷访问的本地数据库；后端存有后端数据库，在对后端数据库进行改写之后，会同步到中控对应的映射数据库并按情况更新到中控数据库，同时通知给前端。

**交叉污染需求：**Shine i8000用于体外诊断，即检测人的体液样本中是否存在某种特定病症。其中样本指的是人类体液，试剂用于检测人类体液。在检测时，需先用样本针将样本加入反应杯中，然后用试剂针L/R加入试剂。此时完成第一份样本的第一个测试的加样，在进行第二个测试的加样前，会触发样本针/试剂针的交叉污染，其中交叉污染类型分为`样本间交叉污染`和`试剂间交叉污染`，其中样本间污染指的是某个项目存在样本间污染，即：高浓度的样本容易对低浓度的样本产生携带污染，为了规避污染，在样本间切换时进行插入清洗。如何判断该样本会对其他样本有污染，若该样本中包含了特定的检测项目，即确定该样本会对下一个样本有污染；而试剂间污染指的是某两个项目之间存在试剂间污染，即A项目测试会对B项目测试产生污染。为了规避污染，在A与B项目间插入清洗。 这种方式也可通过项目间排序测试规避也可以从插入特殊的周期进行清洗。

---

在了解完项目整体架构以及交叉污染需求之后，现在介绍一下业务整体的开发，该业务整体分为交叉污染客户端开发，以及交叉污染服务端开发：

**交叉污染客户端开发：**首先说交叉污染的客户端开发。交叉污染客户端开发分为两个界面，第一个界面用于交叉污染系统设置以及显示交叉污染对；第二个界面用于自定义交叉污染对。

1. **交叉污染系统设置：**对于交叉污染系统设置而言，我们需要设置的是交叉污染开关，清洗液类型，强化清洗液容积，以及使用model/view显示交叉污染对。对于交叉污染系统设置，点击保存之后需要通知给所有后端数据库并且同步更新到中控前端数据库。在点击编辑，新增按钮时，可以进入交叉污染对设置界面

2. **交叉污染对设置：**对于交叉污染对而言，我们需要设置的是交叉污染类型，污染源，受污染项目，以及清洗次数，其中污染源与被污染项目之间存在一对一，一对多，多对一的关系。对于样本间交叉污染，存在同一根样本管不同测试之间的交叉污染，以及不同样本管不同测试之间的交叉污染，试剂间交叉污染也是同理。

   **重点：**在系统设置界面点击编辑按钮的时候，我们需要切换显示已选择已选择的污染源/被污染项目，如果此时采用信号槽的方式连接，会导致代码冗余度很高，而且频繁使用信号槽会降低系统运行效率。通过研究，最终采用了eventfilter过滤派发下来的事件，这样在不使用信号槽的情况下，可以一定程度上提高我们系统运行的效率。

**交叉污染服务端开发：**服务端的开发是本次开发的一个重点内容，主要分为三个部分：交叉污染对的存储，交叉污染对在后端的使用，交叉污染检查库的开发。

1. **交叉污染对的存储：**首先说交叉污染对的存储。本身污染对的存储不难，原本的流程是按照公司的通信协议在前端打包好要存储的系统设置/污染对，然后在后端创建一个交叉污染表的类，对前端的数据进行解析，然后存入数据库。需要注意的是系统设置和污染对存储走的是两条不同的路径，系统设置存储在系统表中，存储之后需要同步更新到内存；污染对存储在污染表中，存储之后不用同步更新到内存。需要注意两者在数据库完成存储之后都需要同步通知中控数据库更新并且通知到前端更新显示界面。

   **重点：**该模块的一个重点是由于以往的数据管理不规范，导致前后端代码耦合度过高，占用了大量网络传输的消息ID，所以以往进行网络传输的代码逻辑不具备参考性，需要我进行重新优化。

   在优化之前，首先我们要明白为什么以前的不行，在仔细研究之后，他主要体现在以下两个方面：

   - 在以前前端对数据进行打包的时候，他会按照字段顺序进行打包。比如我有三个字段名A，B，C，对应的数据分别为1，2，3，那么在存储的时候就是直接存储的1，2，3，解析的时候按顺序解析出1，2，3，并存储到A，B，C中，普通情况下是没问题的，但如果我在前端不小心存储成了1，3，2，这样在后端存储到数据库中的时候B和C就存反了。
   - 第二点就是说比如我需要对污染对进行增加，修改，删除。按照以往的逻辑，增加需要占一个消息ID，修改需要占一个消息ID，删除也需要占一个消息ID，也就是说对于一张表我至少需要3个消息ID，当表的数量一多起来，会造成整体代码的冗余度非常高，在后端一个接收前端数据的一个接口，一个函数就达到了2w行，这是非常不好的。
   - 那么结合以上两点，我制定了以下新的规范：首先看公司自定义的网络通信协议，主要分为三部分：消息ID，字符串，字符串数组。其次看公司后端的线程通信协议，主要也分为三个部分：消息ID，一维字符串数组，二维字符串数组。对于`消息ID`而言，我规定用于存放要操作的数据库名称，比如我要将污染对存放在A数据库的A3数据表中，那此时消息ID应该存A数据库的名称；而`字符串/一维字符串数组`中应该存放具体要操作的数据表名称和数据表的操作，两者之间用逗号隔开；`字符串数组/二维字符串数组`中应该按照“字段名1@@数据1，字段名2@@数据2……”的形式进行存储，其中字段名与数据之间用@@进行隔开，不同字段名之间使用逗号进行隔开，一条记录对应一个一维数组。这样新的规定就可以很好的解决以上问题

交叉污染在后端的使用以及交叉污染库的开发是本次项目两个最大的难点，在进行这两个模块的开发前，我们首先需要阅读代码，了解两个东西，一个是后端的整体架构，另一个是状态机：首先项目入口是main.cpp和AllEntry.cpp，在这两个文件里面会先初始化后端的所有线程并使线程进入轮询状态。我接触了四个线程，分别是：DataServer，LocalServer，DriverBoardServer，DriverBoardServerHandle。

**DataServer：**用于数据处理，并存入数据库。

**LocalServer：**用于指令调度，其中有两个很关键的东西，一个叫排序库，一个叫CycleActionHandle的单例类，其中排序库会把Localserver提交上来的所有指令进行排序，并将排序结果以数据帧的形式返回给LocalServer，然后LocalServer再将该帧发送给DriverBoardServer，DriverBoardServer再发送给MCU。需要注意对于Shine i8000的机型而言，是4s一个周期，所以我调用排序接口，以及转发给DriverBoardServer线程的时间间隔也是4s。然后就是CycleActionHandle类，他大致的用途是对样本和该样本的测试结果进行绑定，因为当我在第二个周期收到一个测试结果时，该测试结果对应的不一定是当前周期申请测试的样本，而是第一个周期申请测试的样本，

**DriverBoardServer：**用于与MCU进行通信，包括接收，解密MCU传来的信息，并向MCU下发数据帧（周期指令）

**DriverBoardServerHandle：**由于解密MCU信息会占用过长的时间，所以该类的作用是给DriverBoardServer减负。

对于接下来的工作，我们需要重点关注LocalServer，DataServer即可

接下来讲一下状态机，他是结合着消息队列进行实现的：首先他会接收前端/MCU发来的状态改变信号，并且通知到MCU/后端，并且将结果广播到后端的所有线程中。

2. **交叉污染对在后端的使用、修改：**在项目代码中，什么时候会触发交叉污染呢？当DataServer检测到状态机的状态由待机->预运行的时候，我们需要从数据库中查询污染对，并且通知LocalServer更新排序库以及接下来要说的检查库中的交叉污染对。按常理来说，更新完污染对之后，交叉污染的业务就已经结束了。但实际测试的时候发现在触发交叉污染的时候，不论怎么设置，都只能使用普通清洗。结合日志以及断点调试，发现该问题是由于排序库无法识别清洗类型造成的，需要对排序库的结果进行修改，并且由于排序库的不稳定，还需要开发交叉污染检查库对最终的结果进行检验。所以我才会花费很大的精力去了解项目中的状态机，各个线程的作用，以及样本测试的整体流程，这样我才知道后续的代码该写在哪里。

   那现在掌握了前置知识之后，我需要去修改排序库的结果。显然排序库会在周期指令发送之前下发结果，而指令调度是由LocalServer负责的，所以我们应该在LocalServer中寻找相关函数。而且由于在清洗周期中我可能会对采样针，试剂左针，试剂右针同时进行清洗，所以在当前周期分别检测采样针，试剂左针，试剂右针的清洗液类型，那么如何判断当前周期的清洗类型？我们之前在存储完交叉污染系统设置的时候会同步更新到内存中，所以我们只需要根据内存中的数据去更新清洗液类型就好了。需要注意在我们在进行强化清洗液扣减的时候，试剂的强化清洗液和样本的强化清洗液是存放在不同的地方的。而且强化清洗液是存放在试剂盒里的，而试剂盒分为四个试剂腔，我们需要对每个试剂腔进行检查，然后扣减。

   在修改完周期指令之后，对周期指令的合法性进行检查。为了整体系统的运行效率，我们只有在样本针/试剂针有吸样/清洗动作时才会对该周期指令进行检查，检查的方式是将对应的数据传入接下来的交叉污染检查库进行检查。

3. **交叉污染检查库的开发：**该库的功能是用于检查排序库的结果是否违反交叉污染规则，如果在吸污染源后未完成足够次数的清洗，就吸被污染项目，则视为违反交叉污染规则。在检查库的开发之前，我们要再捋一遍交叉污染的业务逻辑。首先对于一个交叉污染对而言，分为样本间交叉污染和试剂间交叉污染，污染对的对应关系为1对1，1对多，多对1。其中对于试剂间交叉污染来说，如果污染源与被污染项目位于不同的试剂盘上时，不应该触发交叉污染；在进行解除污染时，有4种类型的清洗：①在加样完成之后固定的周期清洗，该清洗不能算入清洗周期。②插空周期的普通清洗，这个是触发交叉污染规则之后排序库专门安排的一个用于清洗的清洗周期，所以算一次清洗。③插空周期的强化清洗，同理，这个也算一次清洗。注意当强化清洗液耗尽时，会降级为普通清洗，此时也算一次清洗。④重新排列测试顺序，使得项目间插入其他不会被污染的项目，利用周期清洗来解除污染，这个也算一次清洗，对于该类型的清洗来说，既可以当作是普通清洗，也可以当作是强化清洗。整体逻辑还是稍微有点复杂的。

   在捋清楚逻辑之后，该检查库的开发大致分为三部分：①初始化的时候添加污染对，这部分我使用哈希表，key是被污染项目名，value是对应的污染对信息。②在下发周期指令前如果针有吸样/清洗动作的话，就记录该动作，并将之前加样的那些项目的清洗次数加一。③记录完动作之后检查当前周期加样的项目是否违反交叉污染规则，这个是结合第一步和第二步操控的内存进行比较的。

4. **多机型适配：**这个是很简单的内容了，与Shine i8000相比只是周期指令存储的位置不同，改一下枚举值就好了。

## Shine i8000测试作废功能开发



## 基于Qt+Linux的云会议平台

### 多进程编程

这里的每个房间采用独立进程来处理，一方面保证了各个房间数据的私密性，一方面也加强了各个房间的稳定性。

由于进程天然具有内存隔离的特性，所以各个房间的数据不会意外串访。

另外进程的独立性也使得某个房间崩溃的时候，不会让其他房间立刻也一起崩溃。

如果采用多线程来做，一个线程的崩溃，可能导致整个进程的崩溃，进而使得其他房间也失去服务。

### 多线程编程

为了提高服务器对网络数据处理的效率，采用了多线程的模式来处理网络数据。

另外将数据的收发和数据的处理也进行了分离。

接收数据的线程并不会处理数据，而是转发给其他线程或者进程进行处理。

这样能够快速进入下一个数据的接收过程。

避免因为长时间得不到处理而导致客户端失去响应。

一般网络编程的接收过程，往往会伴随着处理过程。

可是处理过程的时间损耗无法估计。

一旦损耗过大，就会反过来影响网络的接收过程。

所以这里进行了分离，接收是接收的线程，处理则是另外的线程。

接收效率大大提高，客户端的请求数据吞吐能力也显著增强。

 

### 网络编程

我没有使用epoll而是使用了select做为服务器的网络框架。

这里主要有以下的考量：

1. Epoll模型更为复杂，开发和维护成本更高。
2. 涉及视频传输的服务器，其瓶颈往往是带宽而不是其他硬件资源。也就是并发量往往不会太大，一般在200左右。因为一个用户500k的带宽，200个用户意味着100M的带宽。这个带宽成本已经非常高了。
3. 视频会议中一个房间的人数并不会太夸张，往往是几十到上百。更大规模的视频会议，需要的是直播而不是视频会议。因为超过一百规模的会议，不可能所有用户同时进行网络视频，这个是带宽无法承受的。而且这样的会议也会有主讲人。这种场景下，直播会更方便。我的目标是做一个小巧的视频会议系统，而不是大型的直播系统。

综上所述，我选择select而非epoll。

我认为前者更适合我的这个项目。

### 视频会议服务器

简单的视频会议服务器核心功能其实是提供房间服务。

比如房间的创建和销毁。

用户加入和离开房间。

用户在房间中获得的消息转发服务等等。

视频数据在服务器也只是一个普通的数据包，只是尺寸可能大一点点而已。

所以这里服务器采用了Linux系统，这种系统内存占用较小的操作系统。

这样可以腾出更多资源来开启房间进程，提供更高的服务上限，最大可能的提高硬件资源的利用率。

 

## 项目问题

### 如何实现进程池？其作用是什么？

在Linux中使用fork就可以很容易的创建进程，但是管理这些进程则较为麻烦。

我首先要解决的问题是进程间的通信。

我这里选用了sendmsg和recvmsg来完成通信。

这种模式的好处在以下几个方面：

一，其具有私密性。使用本地套接字通信，也是可以的。但是其他进程也可以通过此本地ip和端口访问这个通信通道。

二，其具有易用性。相较于管道和套接字，这种模式下，接收者可以直接拿到包长度。

基于这些方面的考量，我选择了此模式来完成通信。

完成了通信，那么进程池也就好实现了。

首先是完成进程的通信模块。

利用这个模块就可以控制其他进程了。

然后还是利用这个进程，还可以向其他进程收发数据。

这样本进程就可以控制和传输数据。

然后统一编号，就可以批量处理这些进程，形成进程池操作了。

有了进程池，我们就可以将一些业务丢给这些进程池去完成，把主进程从业务处理的繁杂耗时任务中解放出来，做一些更重要的调度和控制工作。

### 如何实现线程池？其作用是什么？

线程池的实现要比进程池更加容易，因为线程池中的各个线程之间，内存是互通的。

这样线程控制和数据传输就更为容易。

线程池一般用于执行同质化的多个任务。

比如select的事件处理。

处理过程其实是同质化的（同质化：具有同样的性质，或者功能可以并列。比如都是网络处理。同质化不意味着完全一样：同样是网络处理，A线程是用户登录消息，B线程可能是用户文字消息）。

其作用是尽可能的提高硬件的利用效率。

包括提高网络利用效率、处理器利用效率等等。

比如单个任务可能只会使用到处理器5%的性能，而这些任务的触发时机又很随机。

那么创建一个20线程的线程池，来做任务处理。

高峰的时候就可以同时处理20个任务，将处理器的性能利用到100%。

 

### 为什么网络通信使用select而不是epoll？

我没有使用epoll而是使用了select做为服务器的网络框架。

这里主要有以下的考量：

4. Epoll模型更为复杂，开发和维护成本更高。
5. 涉及视频传输的服务器，其瓶颈往往是带宽而不是其他硬件资源。也就是并发量往往不会太大，一般在200左右。因为一个用户500k的带宽，200个用户意味着100M的带宽。这个带宽成本已经非常高了。
6. 视频会议中一个房间的人数并不会太夸张，往往是几十到上百。更大规模的视频会议，需要的是直播而不是视频会议。因为超过一百规模的会议，不可能所有用户同时进行网络视频，这个是带宽无法承受的。而且这样的会议也会有主讲人。这种场景下，直播会更方便。我的目标是做一个小巧的视频会议系统，而不是大型的直播系统。

综上所述，我选择select而非epoll。

我认为前者更适合我的这个项目。

### 进程间通信有哪些方法？你的项目中选用了哪一种？为什么？

我这里选用了sendmsg和recvmsg来完成进程间通信。

这种模式的好处在以下几个方面：

一，其具有私密性。使用本地套接字通信，也是可以的。但是其他进程也可以通过此本地ip和端口访问这个通信通道。

二，其具有易用性。相较于管道和套接字，这种模式下，接收者可以直接拿到包长度。

 

基于这些方面的考量，我选择了此模式来完成通信。

 

### 用户加入房间的过程能简单描述一下吗？

服务器启动，我们会依据参数创建好房间

然后用户连接服务器。

然后用户选择创建房间，这样我们会将从房间池里面选择一个空房间发给用户。

如果没有，则创建失败。

 

然后其他用户上线。

这些用户填入房间号，我们就会将该用户ID分配给指定的房间。

接着向房间内的所有用户发出消息，通知用户加入。

 

经过上面的步骤之后，用户就加入了房间。

 

### 请描述一下在房间中传输视频信息和文字信息的过程

客户端在产生视频帧数据后，会封装成消息发给服务器。

服务器会找到该客户端所在的房间，如果找不到则丢弃，并返回错误提示。

如果找到，则将该数据转发给其他所有的用户。

其他用户拿到帧数据，解析成功后，再将帧画面显示在界面上。

文字信息也是同样的过程。

 

### Linux下信号是什么？你是如何处理的？

信号是操作系统响应某些条件而产生的一个事件。

信号的定义是在signal.h头文件里面的。

信号本质上是软件中断，是对中断在软件上的模拟，是异步通信，也是一种跨进程通信。

我在项目中主要处理了SIGCHLD和SIGPIPE信号

前者表示子进程结束，后者表示管道错误。

这些都是在多进程编程的时候需要处理的信号。

我采用sigaction函数来注册信号处理函数。

对于管道错误信号，我直接进行忽略处理。

而对于进程结束信号，我实现了sig_chld函数来进行处理。

在该函数中，我调用了waitpid函数来回收子进程资源。

同时设置了WNOHANG标志，来进行非阻塞处理。

这些就是我如何处理信号的。

### 如何自定义信号处理过程？

自定义信号处理过程分为两步：

第一步是注册信号处理函数。

这个需要使用到sigaction函数。

该函数的第一个参数指定要自己定义处理的信号值。第二个参数指定一个sigaction结构体。

该结构体包含了一个函数指针。我们可以把这个指针指向我们自定义的处理函数。

第二步就是实现这个处理函数。

这个函数有两种形式，一种是单参数形式，参数就是信号的值。

一种则复杂一点，还有一个siginfo_t 参数和void*指针，可以从里面解析出更多的值。

这种一般用于段错误、除零错误等特殊情况。

经过上面两步，我们就可以完整的实现自定义信号的处理过程。

本项目中，子进程结束信号就需要我们自己来处理。

在自定义处理中，我们加入了一些日志信息，可以很好的监视子进程的情况。

这个功能在多进程开发过程中非常重要，很多bug需要通过这样的方式来定义和发现。

 

### Linux线程间传输数据有哪些方法？你的项目选择的是哪一种？为什么？

线程间传输数据的方法比较多，比较常用的有直接内存访问，本地网络传输，管道，文件等等方法。

本项目我选择的直接内存访问。

这种方法的缺点是在多线程环境下，容易出现访问冲突。

为了解决这个问题，我使用了Linux的线程锁。

访问之前先上锁，然后再进行读写。完成读写操作后，再进行解锁。

这样多个线程同时访问该数据的时候，只会有一个线程能拿到访问权。

使用这种方式，主要是基于两点考虑。

第一是这种方式需要的内存冗余较小。数据基本无需反复复制或者拷贝。

建立一个全局可访问的队列，有什么数据直接放入队列即可。

用完直接从队列删除。

如果是网络或者管道模式，则需要建立发送或者接收缓冲区。

同一个数据，可能在传输过程中多次被复制或者缓冲。

第二是这种方式速度快成本低。

比如文件方式，其速度就远远比不上内存直接访问。

第三是这种方式简单易维护。

简单就意味着错误的概率小，容易上手和理解。

这样就容易维护。有问题，无论是分析问题，定位问题还是解决问题都要容易很多。

其他方式这方面则有很大的劣势。

综上，我选择了带互斥锁的直接内存访问的方式来进行线程间数据传输。

### 你的项目中遇到过哪些问题？你是如何解决的？

最大的问题是跨进程调试问题。

尤其是开发阶段，子进程会出现各种问题，然后突然闪退。

断点都不好下。

用gdb调试的时候，一开始也不知道在哪里下断点。

单步gdb操作起来非常费时费力。

而且不一定那一次就能触发bug。

所以后面是结合日志分析的办法来定位问题的。

具体做法如下：

首先实现一个日志模块，利用宏来降低日志成本。

然后在相关流程路径上的各个函数入口和出口添加日志。

当发现子进程异常退出的时候，先分析代码，找到一个大致的范围。

比如日志到了哪个模块的哪个函数消失的。

然后将该函数的参数、返回值、局部相关的变量都打印出来。

并且添加日志，看看具体是到哪一行日志消失的。

然后拿着这些参数的值，结合代码一步步分析哪里可能出错。

必要的时候，还需要查看一些其他被调用函数的返回值或者参数的值。

经过上面的操作之后，问题都能能够定位出来，并且找到崩溃原因。

但是解决这些问题还需要再分析一下。

因为有的可能单纯是代码输入错误，有的可能是流程设计就有问题——一些特殊情况没考虑到。

完成之后，还要再复测一下，确保问题真正解决了。

最后去掉无关的日志，再次测试一下，进行验证。

其他的，我认为问题不大。因为整个项目难度并不算太大。

 
